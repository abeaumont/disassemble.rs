var searchIndex = {};
searchIndex["disassemble"] = {"doc":"# Disassemble","items":[[3,"Address","disassemble","The location of something in an address space.",null,null],[3,"BasicBlock","","A [basic block] is a sequence of instructions with no inward-bound\nbranches except to the entry point and no outward-bound branches\nexcept at the exit.",null,null],[12,"name","","The name of the basic block. Not all blocks have meaningful names.",0,null],[12,"address","","The address of the first instruction in the basic block.",0,null],[12,"instructions","","The instructions within this basic block.",0,null],[3,"BasicBlockEdge","","Information about an edge between 2 [basic blocks].",null,null],[12,"edge_type","","Is this edge taken [conditionally or unconditionally]?",1,null],[12,"direction","","Is this an inbound or outbound edge?",1,null],[3,"CFG","","A [control flow graph].",null,null],[12,"graph","","The [`Graph`] that stores the actual CFG",2,null],[12,"entry_block","","The [`NodeIndex`] for the entry [`BasicBlock`] for this function.",2,null],[3,"Function","","A function within a program.",null,null],[12,"symbol","","The [symbol] for this function. This provides the name and [`Address`].",3,null],[12,"instructions","","The [instructions] that comprise this function.",3,null],[12,"cfg","","The [control flow graph] for this function. This is build from the\n`instructions`. It is made up of [basic blocks].",3,null],[3,"Symbol","","A symbol within an executable or library. This is a named [address].",null,null],[12,"address","","The [address] of this symbol.",4,null],[12,"name","","The name of this symbol.",4,null],[4,"EdgeType","","When is this edge taken? Conditionally or unconditionally?",null,null],[13,"ConditionalTrue","","This edge is taken when a conditional is true.",5,null],[13,"ConditionalFalse","","This edge is taken when a conditional is false.",5,null],[13,"Unconditional","","This is edge is always taken.",5,null],[11,"partial_cmp","","",6,{"inputs":[{"name":"address"},{"name":"address"}],"output":{"name":"option"}}],[11,"lt","","",6,{"inputs":[{"name":"address"},{"name":"address"}],"output":{"name":"bool"}}],[11,"le","","",6,{"inputs":[{"name":"address"},{"name":"address"}],"output":{"name":"bool"}}],[11,"gt","","",6,{"inputs":[{"name":"address"},{"name":"address"}],"output":{"name":"bool"}}],[11,"ge","","",6,{"inputs":[{"name":"address"},{"name":"address"}],"output":{"name":"bool"}}],[11,"eq","","",6,{"inputs":[{"name":"address"},{"name":"address"}],"output":{"name":"bool"}}],[11,"ne","","",6,{"inputs":[{"name":"address"},{"name":"address"}],"output":{"name":"bool"}}],[11,"cmp","","",6,{"inputs":[{"name":"address"},{"name":"address"}],"output":{"name":"ordering"}}],[11,"hash","","",6,null],[11,"fmt","","",6,{"inputs":[{"name":"address"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",6,{"inputs":[{"name":"address"}],"output":{"name":"address"}}],[11,"new","","Construct an `Address`.",6,{"inputs":[{"name":"u64"}],"output":{"name":"self"}}],[11,"eq","","",5,{"inputs":[{"name":"edgetype"},{"name":"edgetype"}],"output":{"name":"bool"}}],[11,"fmt","","",5,{"inputs":[{"name":"edgetype"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",5,{"inputs":[{"name":"edgetype"}],"output":{"name":"edgetype"}}],[11,"fmt","","",0,{"inputs":[{"name":"basicblock"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Construct a new `BasicBlock`.",0,{"inputs":[{"name":"option"},{"name":"address"}],"output":{"name":"self"}}],[11,"fmt","","",1,{"inputs":[{"name":"basicblockedge"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Construct a new CFG",2,{"inputs":[],"output":{"name":"self"}}],[11,"build","","Build the CFG from the [`instructions`].",2,{"inputs":[{"name":"cfg"},{"name":"vec"}],"output":null}],[11,"new","","Construct a new function",3,{"inputs":[{"name":"symbol"},{"name":"vec"}],"output":{"name":"self"}}],[11,"fmt","","",4,{"inputs":[{"name":"symbol"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Construct a `Symbol`.",4,{"inputs":[{"name":"address"},{"name":"str"}],"output":{"name":"self"}}],[8,"Instruction","","An assembly instruction, bytecode operation, VM operation, etc.",null,null],[10,"address","","The [`address`] of this `Instruction`.",7,{"inputs":[{"name":"instruction"}],"output":{"name":"address"}}],[11,"is_block_terminator","","Does this instruction terminate a `BasicBlock`?",7,{"inputs":[{"name":"instruction"}],"output":{"name":"bool"}}],[10,"is_call","","Does this instruction represent a call?",7,{"inputs":[{"name":"instruction"}],"output":{"name":"bool"}}],[10,"is_local_jump","","Does this instruction represent a local jump?",7,{"inputs":[{"name":"instruction"}],"output":{"name":"bool"}}],[10,"is_return","","Does this instruction represent a function return?",7,{"inputs":[{"name":"instruction"}],"output":{"name":"bool"}}],[11,"is_block_terminator","","Does this instruction terminate a `BasicBlock`?",7,{"inputs":[{"name":"instruction"}],"output":{"name":"bool"}}]],"paths":[[3,"BasicBlock"],[3,"BasicBlockEdge"],[3,"CFG"],[3,"Function"],[3,"Symbol"],[4,"EdgeType"],[3,"Address"],[8,"Instruction"]]};
searchIndex["petgraph"] = {"doc":"**petgraph** is a graph data structure library.","items":[[4,"EdgeDirection","petgraph","Edge direction",null,null],[13,"Outgoing","","An `Outgoing` edge is an outward edge *from* the current node.",0,null],[13,"Incoming","","An `Incoming` edge is an inbound edge *to* the current node.",0,null],[4,"Directed","","Marker type for a directed graph.",null,null],[4,"Undirected","","Marker type for an undirected graph.",null,null],[0,"algo","","Graph algorithms.",null,null],[5,"is_isomorphic","petgraph::algo","Return `true` if the graphs `g0` and `g1` are isomorphic.",null,{"inputs":[{"name":"graph"},{"name":"graph"}],"output":{"name":"bool"}}],[5,"is_isomorphic_matching","","Return `true` if the graphs `g0` and `g1` are isomorphic.",null,{"inputs":[{"name":"graph"},{"name":"graph"},{"name":"f"},{"name":"g"}],"output":{"name":"bool"}}],[5,"dijkstra","","Dijkstra&#39;s shortest path algorithm.",null,{"inputs":[{"name":"g"},{"name":"nodeid"},{"name":"option"},{"name":"f"}],"output":{"name":"hashmap"}}],[5,"is_cyclic_undirected","","Return `true` if the input graph contains a cycle.",null,{"inputs":[{"name":"graph"}],"output":{"name":"bool"}}],[5,"is_cyclic","","**Deprecated: Renamed to `is_cyclic_undirected`.**",null,{"inputs":[{"name":"graph"}],"output":{"name":"bool"}}],[5,"is_cyclic_directed","","Return `true` if the input directed graph contains a cycle.",null,{"inputs":[{"name":"graph"}],"output":{"name":"bool"}}],[5,"toposort","","Perform a topological sort of a directed graph.",null,{"inputs":[{"name":"graph"}],"output":{"name":"vec"}}],[5,"scc","","Compute the *strongly connected components* using Kosaraju&#39;s algorithm.",null,{"inputs":[{"name":"graph"}],"output":{"name":"vec"}}],[5,"condensation","","Condense every strongly connected component into a single node and return the result.",null,{"inputs":[{"name":"graph"},{"name":"bool"}],"output":{"name":"graph"}}],[5,"connected_components","","Return the number of connected components of the graph.",null,{"inputs":[{"name":"graph"}],"output":{"name":"usize"}}],[5,"min_spanning_tree","","Compute a *minimum spanning tree* of a graph.",null,{"inputs":[{"name":"graph"}],"output":{"name":"graph"}}],[0,"graphmap","petgraph","`GraphMap&lt;N, E&gt;` is an undirected graph where node values are mapping keys.",null,null],[3,"GraphMap","petgraph::graphmap","`GraphMap&lt;N, E&gt;` is an undirected graph, with generic node values `N` and edge weights `E`.",null,null],[3,"Nodes","","",null,null],[3,"Neighbors","","",null,null],[3,"Edges","","",null,null],[3,"AllEdges","","",null,null],[3,"Ptr","","A reference that is hashed and compared by its pointer value.",null,null],[12,"0","","",1,null],[8,"NodeTrait","","A trait group for `GraphMap`&#39;s node identifier.",null,null],[11,"clone","","",2,{"inputs":[{"name":"graphmap"}],"output":{"name":"graphmap"}}],[11,"fmt","","",2,{"inputs":[{"name":"graphmap"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new `GraphMap`.",2,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Create a new `GraphMap` with estimated capacity.",2,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"capacity","","Return the current node and edge capacity of the graph.",2,null],[11,"from_edges","","Create a new `GraphMap` from an iterable of edges.",2,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"node_count","","Return the number of nodes in the graph.",2,{"inputs":[{"name":"graphmap"}],"output":{"name":"usize"}}],[11,"edge_count","","Return the number of edges in the graph.",2,{"inputs":[{"name":"graphmap"}],"output":{"name":"usize"}}],[11,"clear","","Remove all nodes and edges",2,{"inputs":[{"name":"graphmap"}],"output":null}],[11,"add_node","","Add node `n` to the graph.",2,{"inputs":[{"name":"graphmap"},{"name":"n"}],"output":{"name":"n"}}],[11,"remove_node","","Return `true` if node `n` was removed.",2,{"inputs":[{"name":"graphmap"},{"name":"n"}],"output":{"name":"bool"}}],[11,"contains_node","","Return `true` if the node is contained in the graph.",2,{"inputs":[{"name":"graphmap"},{"name":"n"}],"output":{"name":"bool"}}],[11,"add_edge","","Add an edge connecting `a` and `b` to the graph, with associated\ndata `weight`.",2,{"inputs":[{"name":"graphmap"},{"name":"n"},{"name":"n"},{"name":"e"}],"output":{"name":"option"}}],[11,"remove_edge","","Remove edge from `a` to `b` from the graph and return the edge weight.",2,{"inputs":[{"name":"graphmap"},{"name":"n"},{"name":"n"}],"output":{"name":"option"}}],[11,"contains_edge","","Return `true` if the edge connecting `a` with `b` is contained in the graph.",2,{"inputs":[{"name":"graphmap"},{"name":"n"},{"name":"n"}],"output":{"name":"bool"}}],[11,"nodes","","Return an iterator over the nodes of the graph.",2,{"inputs":[{"name":"graphmap"}],"output":{"name":"nodes"}}],[11,"neighbors","","Return an iterator over the nodes that are connected with `from` by edges.",2,{"inputs":[{"name":"graphmap"},{"name":"n"}],"output":{"name":"neighbors"}}],[11,"edges","","Return an iterator over the nodes that are connected with `from` by edges,\npaired with the edge weight.",2,{"inputs":[{"name":"graphmap"},{"name":"n"}],"output":{"name":"edges"}}],[11,"edge_weight","","Return a reference to the edge weight connecting `a` with `b`, or\n`None` if the edge does not exist in the graph.",2,{"inputs":[{"name":"graphmap"},{"name":"n"},{"name":"n"}],"output":{"name":"option"}}],[11,"edge_weight_mut","","Return a mutable reference to the edge weight connecting `a` with `b`, or\n`None` if the edge does not exist in the graph.",2,{"inputs":[{"name":"graphmap"},{"name":"n"},{"name":"n"}],"output":{"name":"option"}}],[11,"all_edges","","Return an iterator over all edges of the graph with their weight in arbitrary order.",2,{"inputs":[{"name":"graphmap"}],"output":{"name":"alledges"}}],[11,"from_iter","","",2,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"extend","","",2,{"inputs":[{"name":"graphmap"},{"name":"i"}],"output":null}],[11,"next","","",3,{"inputs":[{"name":"nodes"}],"output":{"name":"option"}}],[11,"size_hint","","",3,null],[11,"next","","",4,{"inputs":[{"name":"neighbors"}],"output":{"name":"option"}}],[11,"size_hint","","",4,null],[11,"next_back","","",4,{"inputs":[{"name":"neighbors"}],"output":{"name":"option"}}],[11,"clone","","",4,{"inputs":[{"name":"neighbors"}],"output":{"name":"self"}}],[11,"next","","",5,{"inputs":[{"name":"edges"}],"output":{"name":"option"}}],[11,"next","","",6,{"inputs":[{"name":"alledges"}],"output":{"name":"option"}}],[11,"index","","",2,null],[11,"index_mut","","",2,null],[11,"default","","",2,{"inputs":[],"output":{"name":"self"}}],[11,"clone","","",1,{"inputs":[{"name":"ptr"}],"output":{"name":"self"}}],[11,"eq","","Ptr compares by pointer equality, i.e if they point to the same value",1,{"inputs":[{"name":"ptr"},{"name":"ptr"}],"output":{"name":"bool"}}],[11,"partial_cmp","","",1,{"inputs":[{"name":"ptr"},{"name":"ptr"}],"output":{"name":"option"}}],[11,"cmp","","Ptr is ordered by pointer value, i.e. an arbitrary but stable and total order.",1,{"inputs":[{"name":"ptr"},{"name":"ptr"}],"output":{"name":"ordering"}}],[11,"deref","","",1,{"inputs":[{"name":"ptr"}],"output":{"name":"t"}}],[11,"hash","","",1,{"inputs":[{"name":"ptr"},{"name":"h"}],"output":null}],[11,"fmt","","",1,{"inputs":[{"name":"ptr"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"graph","petgraph","`Graph&lt;N, E, Ty, Ix&gt;` is a graph datastructure using an adjacency list representation.",null,null],[3,"NodeIndex","petgraph::graph","Node identifier.",null,null],[3,"EdgeIndex","","Edge identifier.",null,null],[3,"Node","","The graph&#39;s node type.",null,null],[12,"weight","","Associated node data.",7,null],[3,"Edge","","The graph&#39;s edge type.",null,null],[12,"weight","","Associated edge data.",8,null],[3,"Graph","","`Graph&lt;N, E, Ty, Ix&gt;` is a graph datastructure using an adjacency list representation.",null,null],[3,"Externals","","An iterator over either the nodes without edges to them or from them.",null,null],[3,"Neighbors","","Iterator over the neighbors of a node.",null,null],[3,"Edges","","Iterator over the edges of a node.",null,null],[3,"NodeWeightsMut","","Iterator yielding mutable access to all node weights.",null,null],[3,"EdgeWeightsMut","","Iterator yielding mutable access to all edge weights.",null,null],[3,"WalkNeighbors","","A “walker” object that can be used to step through the edge list of a node.",null,null],[3,"WalkEdges","","**Deprecated.**",null,null],[3,"NodeIndices","","Iterator over the node indices of a graph.",null,null],[3,"EdgeIndices","","Iterator over the edge indices of a graph.",null,null],[5,"node_index","","Short version of `NodeIndex::new`",null,{"inputs":[{"name":"usize"}],"output":{"name":"nodeindex"}}],[5,"edge_index","","Short version of `EdgeIndex::new`",null,{"inputs":[{"name":"usize"}],"output":{"name":"edgeindex"}}],[6,"DefIndex","","The default integer type for node and edge indices in `Graph`.\n`u32` is the default to reduce the size of the graph&#39;s data and improve\nperformance in the common case.",null,null],[8,"IndexType","","Trait for the unsigned integer type used for node and edge indices.",null,null],[10,"new","","",9,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[10,"index","","",9,{"inputs":[{"name":"indextype"}],"output":{"name":"usize"}}],[10,"max","","",9,{"inputs":[],"output":{"name":"self"}}],[8,"GraphIndex","","A  `GraphIndex` is a node or edge index.",null,null],[11,"hash","","",10,null],[11,"cmp","","",10,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",10,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"option"}}],[11,"lt","","",10,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"le","","",10,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"gt","","",10,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"ge","","",10,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"eq","","",10,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"ne","","",10,{"inputs":[{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"fmt","","",10,{"inputs":[{"name":"nodeindex"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",10,{"inputs":[{"name":"nodeindex"}],"output":{"name":"nodeindex"}}],[11,"new","","",10,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"index","","",10,{"inputs":[{"name":"nodeindex"}],"output":{"name":"usize"}}],[11,"end","","",10,{"inputs":[],"output":{"name":"self"}}],[11,"from","","",10,{"inputs":[{"name":"ix"}],"output":{"name":"self"}}],[11,"hash","","",11,null],[11,"cmp","","",11,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",11,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"option"}}],[11,"lt","","",11,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"bool"}}],[11,"le","","",11,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"bool"}}],[11,"gt","","",11,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"bool"}}],[11,"ge","","",11,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"bool"}}],[11,"eq","","",11,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"bool"}}],[11,"ne","","",11,{"inputs":[{"name":"edgeindex"},{"name":"edgeindex"}],"output":{"name":"bool"}}],[11,"clone","","",11,{"inputs":[{"name":"edgeindex"}],"output":{"name":"edgeindex"}}],[11,"new","","",11,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"index","","",11,{"inputs":[{"name":"edgeindex"}],"output":{"name":"usize"}}],[11,"end","","An invalid `EdgeIndex` used to denote absence of an edge, for example\nto end an adjacency list.",11,{"inputs":[],"output":{"name":"self"}}],[11,"fmt","","",11,{"inputs":[{"name":"edgeindex"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",7,{"inputs":[{"name":"node"}],"output":{"name":"node"}}],[11,"fmt","","",7,{"inputs":[{"name":"node"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"next_edge","","Accessor for data structure internals: the first edge in the given direction.",7,{"inputs":[{"name":"node"},{"name":"edgedirection"}],"output":{"name":"edgeindex"}}],[11,"clone","","",8,{"inputs":[{"name":"edge"}],"output":{"name":"edge"}}],[11,"fmt","","",8,{"inputs":[{"name":"edge"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"next_edge","","Accessor for data structure internals: the next edge for the given direction.",8,{"inputs":[{"name":"edge"},{"name":"edgedirection"}],"output":{"name":"edgeindex"}}],[11,"source","","Return the source node index.",8,{"inputs":[{"name":"edge"}],"output":{"name":"nodeindex"}}],[11,"target","","Return the target node index.",8,{"inputs":[{"name":"edge"}],"output":{"name":"nodeindex"}}],[11,"clone","","",12,{"inputs":[{"name":"graph"}],"output":{"name":"self"}}],[11,"clone_from","","",12,{"inputs":[{"name":"graph"},{"name":"self"}],"output":null}],[11,"fmt","","",12,{"inputs":[{"name":"graph"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new `Graph` with directed edges.",12,{"inputs":[],"output":{"name":"self"}}],[11,"new_undirected","","Create a new `Graph` with undirected edges.",12,{"inputs":[],"output":{"name":"self"}}],[11,"with_capacity","","Create a new `Graph` with estimated capacity.",12,{"inputs":[{"name":"usize"},{"name":"usize"}],"output":{"name":"self"}}],[11,"capacity","","Return the current node and edge capacity of the graph.",12,null],[11,"node_count","","Return the number of nodes (vertices) in the graph.",12,{"inputs":[{"name":"graph"}],"output":{"name":"usize"}}],[11,"edge_count","","Return the number of edges in the graph.",12,{"inputs":[{"name":"graph"}],"output":{"name":"usize"}}],[11,"is_directed","","Whether the graph has directed edges or not.",12,{"inputs":[{"name":"graph"}],"output":{"name":"bool"}}],[11,"add_node","","Add a node (also called vertex) with associated data `weight` to the graph.",12,{"inputs":[{"name":"graph"},{"name":"n"}],"output":{"name":"nodeindex"}}],[11,"node_weight","","Access the weight for node `a`.",12,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"option"}}],[11,"node_weight_mut","","Access the weight for node `a`, mutably.",12,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"option"}}],[11,"add_edge","","Add an edge from `a` to `b` to the graph, with its associated\ndata `weight`.",12,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"nodeindex"},{"name":"e"}],"output":{"name":"edgeindex"}}],[11,"update_edge","","Add or update an edge from `a` to `b`.\nIf the edge already exists, its weight is updated.",12,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"nodeindex"},{"name":"e"}],"output":{"name":"edgeindex"}}],[11,"edge_weight","","Access the weight for edge `e`.",12,{"inputs":[{"name":"graph"},{"name":"edgeindex"}],"output":{"name":"option"}}],[11,"edge_weight_mut","","Access the weight for edge `e`, mutably.",12,{"inputs":[{"name":"graph"},{"name":"edgeindex"}],"output":{"name":"option"}}],[11,"edge_endpoints","","Access the source and target nodes for `e`.",12,{"inputs":[{"name":"graph"},{"name":"edgeindex"}],"output":{"name":"option"}}],[11,"remove_node","","Remove `a` from the graph if it exists, and return its weight.\nIf it doesn&#39;t exist in the graph, return `None`.",12,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"option"}}],[11,"remove_edge","","Remove an edge and return its edge weight, or `None` if it didn&#39;t exist.",12,{"inputs":[{"name":"graph"},{"name":"edgeindex"}],"output":{"name":"option"}}],[11,"neighbors","","Return an iterator of all nodes with an edge starting from `a`.",12,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"neighbors"}}],[11,"neighbors_directed","","Return an iterator of all neighbors that have an edge between them and `a`,\nin the specified direction.\nIf the graph&#39;s edges are undirected, this is equivalent to *.neighbors(a)*.",12,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"edgedirection"}],"output":{"name":"neighbors"}}],[11,"neighbors_undirected","","Return an iterator of all neighbors that have an edge between them and `a`,\nin either direction.\nIf the graph&#39;s edges are undirected, this is equivalent to *.neighbors(a)*.",12,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"neighbors"}}],[11,"edges","","Return an iterator over the neighbors of node `a`, paired with their respective edge\nweights.",12,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"edges"}}],[11,"edges_directed","","Return an iterator of all neighbors that have an edge between them and `a`,\nin the specified direction, paired with the respective edge weights.",12,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"edgedirection"}],"output":{"name":"edges"}}],[11,"find_edge","","Lookup an edge from `a` to `b`.",12,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"option"}}],[11,"find_edge_undirected","","Lookup an edge between `a` and `b`, in either direction.",12,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"option"}}],[11,"externals","","Return an iterator over either the nodes without edges to them\n(`Incoming`) or from them (`Outgoing`).",12,{"inputs":[{"name":"graph"},{"name":"edgedirection"}],"output":{"name":"externals"}}],[11,"node_indices","","Return an iterator over the node indices of the graph",12,{"inputs":[{"name":"graph"}],"output":{"name":"nodeindices"}}],[11,"node_weights_mut","","Return an iterator yielding mutable access to all node weights.",12,{"inputs":[{"name":"graph"}],"output":{"name":"nodeweightsmut"}}],[11,"edge_indices","","Return an iterator over the edge indices of the graph",12,{"inputs":[{"name":"graph"}],"output":{"name":"edgeindices"}}],[11,"edge_weights_mut","","Return an iterator yielding mutable access to all edge weights.",12,{"inputs":[{"name":"graph"}],"output":{"name":"edgeweightsmut"}}],[11,"raw_nodes","","Access the internal node array.",12,null],[11,"raw_edges","","Access the internal edge array.",12,null],[11,"into_nodes_edges","","Convert the graph into a vector of Nodes and a vector of Edges",12,null],[11,"first_edge","","Accessor for data structure internals: the first edge in the given direction.",12,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"edgedirection"}],"output":{"name":"option"}}],[11,"next_edge","","Accessor for data structure internals: the next edge for the given direction.",12,{"inputs":[{"name":"graph"},{"name":"edgeindex"},{"name":"edgedirection"}],"output":{"name":"option"}}],[11,"walk_edges_directed","","**Deprecated:** Use [`.neighbors_directed(a, dir).detach()`][1] instead.",12,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"edgedirection"}],"output":{"name":"walkedges"}}],[11,"index_twice_mut","","Index the `Graph` by two indices, any combination of\nnode or edge indices is fine.",12,null],[11,"reverse","","Reverse the direction of all edges",12,{"inputs":[{"name":"graph"}],"output":null}],[11,"clear","","Remove all nodes and edges",12,{"inputs":[{"name":"graph"}],"output":null}],[11,"clear_edges","","Remove all edges",12,{"inputs":[{"name":"graph"}],"output":null}],[11,"retain_nodes","","Keep all nodes that return `true` from the `visit` closure,\nremove the others.",12,{"inputs":[{"name":"graph"},{"name":"f"}],"output":null}],[11,"retain_edges","","Keep all edges that return `true` from the `visit` closure,\nremove the others.",12,{"inputs":[{"name":"graph"},{"name":"f"}],"output":null}],[11,"from_edges","","Create a new `Graph` from an iterable of edges.",12,{"inputs":[{"name":"i"}],"output":{"name":"self"}}],[11,"extend_with_edges","","Extend the graph from an iterable of edges.",12,{"inputs":[{"name":"graph"},{"name":"i"}],"output":null}],[11,"map","","Create a new `Graph` by mapping node and\nedge weights to new values.",12,{"inputs":[{"name":"graph"},{"name":"f"},{"name":"g"}],"output":{"name":"graph"}}],[11,"filter_map","","Create a new `Graph` by mapping nodes and edges.\nA node or edge may be mapped to `None` to exclude it from\nthe resulting graph.",12,{"inputs":[{"name":"graph"},{"name":"f"},{"name":"g"}],"output":{"name":"graph"}}],[11,"into_edge_type","","Convert the graph into either undirected or directed. No edge adjustments\nare done, so you may want to go over the result to remove or add edges.",12,{"inputs":[{"name":"graph"}],"output":{"name":"graph"}}],[11,"next","","",13,{"inputs":[{"name":"externals"}],"output":{"name":"option"}}],[11,"next","","",14,{"inputs":[{"name":"neighbors"}],"output":{"name":"option"}}],[11,"clone","","",14,{"inputs":[{"name":"neighbors"}],"output":{"name":"self"}}],[11,"detach","","Return a “walker” object that can be used to step through the\nneighbors and edges from the origin node.",14,{"inputs":[{"name":"neighbors"}],"output":{"name":"walkneighbors"}}],[11,"next","","",15,{"inputs":[{"name":"edges"}],"output":{"name":"option"}}],[11,"clone","","",15,{"inputs":[{"name":"edges"}],"output":{"name":"self"}}],[11,"next","","",16,{"inputs":[{"name":"nodeweightsmut"}],"output":{"name":"option"}}],[11,"size_hint","","",16,null],[11,"next","","",17,{"inputs":[{"name":"edgeweightsmut"}],"output":{"name":"option"}}],[11,"size_hint","","",17,null],[11,"index","","",12,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"n"}}],[11,"index_mut","","",12,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"n"}}],[11,"index","","",12,{"inputs":[{"name":"graph"},{"name":"edgeindex"}],"output":{"name":"e"}}],[11,"index_mut","","",12,{"inputs":[{"name":"graph"},{"name":"edgeindex"}],"output":{"name":"e"}}],[11,"default","","",12,{"inputs":[],"output":{"name":"self"}}],[11,"index","","",10,{"inputs":[{"name":"nodeindex"}],"output":{"name":"usize"}}],[11,"is_node_index","","",10,{"inputs":[],"output":{"name":"bool"}}],[11,"index","","",11,{"inputs":[{"name":"edgeindex"}],"output":{"name":"usize"}}],[11,"is_node_index","","",11,{"inputs":[],"output":{"name":"bool"}}],[11,"clone","","",18,{"inputs":[{"name":"walkneighbors"}],"output":{"name":"self"}}],[11,"next","","Step to the next edge and its endpoint node in the walk for graph `g`.",18,{"inputs":[{"name":"walkneighbors"},{"name":"graph"}],"output":{"name":"option"}}],[11,"next_node","","",18,{"inputs":[{"name":"walkneighbors"},{"name":"graph"}],"output":{"name":"option"}}],[11,"next_edge","","",18,{"inputs":[{"name":"walkneighbors"},{"name":"graph"}],"output":{"name":"option"}}],[11,"fmt","","",19,{"inputs":[{"name":"walkedges"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",19,{"inputs":[{"name":"walkedges"}],"output":{"name":"walkedges"}}],[11,"next","","Fetch the next edge index in the walk for graph `g`.",19,{"inputs":[{"name":"walkedges"},{"name":"graph"}],"output":{"name":"option"}}],[11,"next_neighbor","","Fetch the next edge index and the next node index in the walk for graph `g`.",19,{"inputs":[{"name":"walkedges"},{"name":"graph"}],"output":{"name":"option"}}],[11,"fmt","","",20,{"inputs":[{"name":"nodeindices"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",20,{"inputs":[{"name":"nodeindices"}],"output":{"name":"nodeindices"}}],[11,"next","","",20,{"inputs":[{"name":"nodeindices"}],"output":{"name":"option"}}],[11,"size_hint","","",20,null],[11,"next_back","","",20,{"inputs":[{"name":"nodeindices"}],"output":{"name":"option"}}],[11,"fmt","","",21,{"inputs":[{"name":"edgeindices"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",21,{"inputs":[{"name":"edgeindices"}],"output":{"name":"edgeindices"}}],[11,"next","","",21,{"inputs":[{"name":"edgeindices"}],"output":{"name":"option"}}],[11,"size_hint","","",21,null],[11,"next_back","","",21,{"inputs":[{"name":"edgeindices"}],"output":{"name":"option"}}],[0,"dot","petgraph","Simple graphviz dot file format output.",null,null],[3,"Dot","petgraph::dot","`Dot` implements output to graphviz .dot format for a graph.",null,null],[4,"Config","","`Dot` configuration.",null,null],[13,"NodeIndexLabel","","Use indices for node labels.",22,null],[13,"EdgeIndexLabel","","Use indices for edge labels.",22,null],[13,"EdgeNoLabel","","Use no edge labels.",22,null],[11,"new","","Create a `Dot` formatting wrapper with default configuration.",23,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"with_config","","Create a `Dot` formatting wrapper with custom configuration.",23,null],[11,"eq","","",22,{"inputs":[{"name":"config"},{"name":"config"}],"output":{"name":"bool"}}],[11,"ne","","",22,{"inputs":[{"name":"config"},{"name":"config"}],"output":{"name":"bool"}}],[11,"fmt","","",22,{"inputs":[{"name":"config"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",23,{"inputs":[{"name":"dot"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",23,{"inputs":[{"name":"dot"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",23,{"inputs":[{"name":"dot"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",23,{"inputs":[{"name":"dot"},{"name":"formatter"}],"output":{"name":"result"}}],[0,"visit","petgraph","Graph visitor algorithms.",null,null],[3,"AsUndirected","petgraph::visit","Wrapper type for walking the graph as if it is undirected",null,null],[12,"0","","",24,null],[3,"Reversed","","Wrapper type for walking the graph as if all edges are reversed.",null,null],[12,"0","","",25,null],[3,"Dfs","","A depth first search (DFS) of a graph.",null,null],[12,"stack","","The stack of nodes to visit",26,null],[12,"discovered","","The map of discovered nodes",26,null],[3,"DfsIter","","An iterator for a depth first traversal of a graph.",null,null],[3,"Bfs","","A breadth first search (BFS) of a graph.",null,null],[12,"stack","","The queue of nodes to visit",27,null],[12,"discovered","","The map of discovered nodes",27,null],[3,"BfsIter","","An iterator for a breadth first traversal of a graph.",null,null],[3,"Topo","","A topological order traversal for a graph.",null,null],[3,"SubTopo","","A topological order traversal for a subgraph.",null,null],[8,"Graphlike","","Base trait for graphs that defines the node identifier.",null,null],[16,"NodeId","","",28,null],[8,"NeighborIter","","NeighborIter gives access to the neighbors iterator.",null,null],[16,"Iter","","",29,null],[10,"neighbors","","Return an iterator that visits all neighbors of the node **n**.",29,{"inputs":[{"name":"neighboriter"},{"name":"nodeid"}],"output":{"name":"iter"}}],[8,"NeighborsDirected","","NeighborsDirected gives access to neighbors of both `Incoming` and `Outgoing`\nedges of a node.",null,null],[16,"NeighborsDirected","","",30,null],[10,"neighbors_directed","","Return an iterator that visits all neighbors of the node **n**.",30,{"inputs":[{"name":"neighborsdirected"},{"name":"nodeid"},{"name":"edgedirection"}],"output":{"name":"neighborsdirected"}}],[8,"Externals","","Externals returns an iterator of all nodes that either have either no\nincoming or no outgoing edges.",null,null],[16,"Externals","","",31,null],[10,"externals","","Return an iterator of all nodes with no edges in the given direction",31,{"inputs":[{"name":"externals"},{"name":"edgedirection"}],"output":{"name":"externals"}}],[8,"VisitMap","","A mapping for storing the visited status for NodeId `N`.",null,null],[10,"visit","","Return **true** if the value is not already present.",32,{"inputs":[{"name":"visitmap"},{"name":"n"}],"output":{"name":"bool"}}],[10,"is_visited","","",32,{"inputs":[{"name":"visitmap"},{"name":"n"}],"output":{"name":"bool"}}],[8,"Visitable","","A graph that can create a visitor map.",null,null],[16,"Map","","",33,null],[10,"visit_map","","",33,{"inputs":[{"name":"visitable"}],"output":{"name":"map"}}],[8,"Revisitable","","A graph that can reset and resize its visitor map.",null,null],[10,"reset_map","","",34,{"inputs":[{"name":"revisitable"},{"name":"map"}],"output":null}],[8,"GetAdjacencyMatrix","","Create or access the adjacency matrix of a graph",null,null],[16,"AdjMatrix","","",35,null],[10,"adjacency_matrix","","",35,{"inputs":[{"name":"getadjacencymatrix"}],"output":{"name":"adjmatrix"}}],[10,"is_adjacent","","",35,{"inputs":[{"name":"getadjacencymatrix"},{"name":"adjmatrix"},{"name":"nodeid"},{"name":"nodeid"}],"output":{"name":"bool"}}],[11,"neighbors","petgraph::graph","",12,{"inputs":[{"name":"graph"},{"name":"nodeindex"}],"output":{"name":"neighbors"}}],[11,"neighbors","petgraph::graphmap","",2,{"inputs":[{"name":"graphmap"},{"name":"n"}],"output":{"name":"neighbors"}}],[11,"neighbors","petgraph::visit","",24,{"inputs":[{"name":"asundirected"},{"name":"nodeindex"}],"output":{"name":"neighbors"}}],[11,"neighbors","","",25,{"inputs":[{"name":"reversed"},{"name":"nodeindex"}],"output":{"name":"neighbors"}}],[11,"neighbors_directed","petgraph::graph","",12,{"inputs":[{"name":"graph"},{"name":"nodeindex"},{"name":"edgedirection"}],"output":{"name":"neighbors"}}],[11,"neighbors_directed","petgraph::visit","",25,{"inputs":[{"name":"reversed"},{"name":"nodeid"},{"name":"edgedirection"}],"output":{"name":"neighborsdirected"}}],[11,"externals","petgraph::graph","",12,{"inputs":[{"name":"graph"},{"name":"edgedirection"}],"output":{"name":"externals"}}],[11,"externals","petgraph::visit","",25,{"inputs":[{"name":"reversed"},{"name":"edgedirection"}],"output":{"name":"externals"}}],[11,"visit","fixedbitset","",36,{"inputs":[{"name":"fixedbitset"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"is_visited","","",36,{"inputs":[{"name":"fixedbitset"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[11,"visit","","",36,{"inputs":[{"name":"fixedbitset"},{"name":"edgeindex"}],"output":{"name":"bool"}}],[11,"is_visited","","",36,{"inputs":[{"name":"fixedbitset"},{"name":"edgeindex"}],"output":{"name":"bool"}}],[11,"visit","std::collections::hash::set","",37,{"inputs":[{"name":"hashset"},{"name":"n"}],"output":{"name":"bool"}}],[11,"is_visited","","",37,{"inputs":[{"name":"hashset"},{"name":"n"}],"output":{"name":"bool"}}],[11,"visit_map","petgraph::graph","",12,{"inputs":[{"name":"graph"}],"output":{"name":"fixedbitset"}}],[11,"reset_map","","",12,{"inputs":[{"name":"graph"},{"name":"map"}],"output":null}],[11,"reset_map","petgraph::visit","",25,{"inputs":[{"name":"reversed"},{"name":"map"}],"output":null}],[11,"visit_map","petgraph::graphmap","",2,{"inputs":[{"name":"graphmap"}],"output":{"name":"hashset"}}],[11,"reset_map","","",2,{"inputs":[{"name":"graphmap"},{"name":"map"}],"output":null}],[11,"visit_map","petgraph::visit","",24,{"inputs":[{"name":"asundirected"}],"output":{"name":"map"}}],[11,"visit_map","","",25,{"inputs":[{"name":"reversed"}],"output":{"name":"map"}}],[11,"adjacency_matrix","petgraph::graphmap","",2,{"inputs":[{"name":"graphmap"}],"output":null}],[11,"is_adjacent","","",2,null],[11,"fmt","petgraph::visit","",26,{"inputs":[{"name":"dfs"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",26,{"inputs":[{"name":"dfs"}],"output":{"name":"dfs"}}],[11,"new","","Create a new **Dfs**, using the graph&#39;s visitor map, and put **start**\nin the stack of nodes to visit.",26,{"inputs":[{"name":"g"},{"name":"n"}],"output":{"name":"self"}}],[11,"empty","","Create a new **Dfs** using the graph&#39;s visitor map, and no stack.",26,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"move_to","","Keep the discovered map, but clear the visit stack and restart\nthe dfs from a particular node.",26,{"inputs":[{"name":"dfs"},{"name":"n"}],"output":null}],[11,"next","","Return the next node in the dfs, or **None** if the traversal is done.",26,{"inputs":[{"name":"dfs"},{"name":"g"}],"output":{"name":"option"}}],[11,"new","","",38,{"inputs":[{"name":"g"},{"name":"nodeid"}],"output":{"name":"self"}}],[11,"move_to","","Keep the discovered map, but clear the visit stack and restart\nthe DFS traversal from a particular node.",38,{"inputs":[{"name":"dfsiter"},{"name":"nodeid"}],"output":null}],[11,"next","","",38,{"inputs":[{"name":"dfsiter"}],"output":{"name":"option"}}],[11,"size_hint","","",38,null],[11,"clone","","",38,{"inputs":[{"name":"dfsiter"}],"output":{"name":"self"}}],[11,"clone","","",27,{"inputs":[{"name":"bfs"}],"output":{"name":"bfs"}}],[11,"new","","Create a new **Bfs**, using the graph&#39;s visitor map, and put **start**\nin the stack of nodes to visit.",27,{"inputs":[{"name":"g"},{"name":"n"}],"output":{"name":"self"}}],[11,"next","","Return the next node in the dfs, or **None** if the traversal is done.",27,{"inputs":[{"name":"bfs"},{"name":"g"}],"output":{"name":"option"}}],[11,"new","","",39,{"inputs":[{"name":"g"},{"name":"nodeid"}],"output":{"name":"self"}}],[11,"next","","",39,{"inputs":[{"name":"bfsiter"}],"output":{"name":"option"}}],[11,"size_hint","","",39,null],[11,"clone","","",39,{"inputs":[{"name":"bfsiter"}],"output":{"name":"self"}}],[11,"clone","","",40,{"inputs":[{"name":"topo"}],"output":{"name":"topo"}}],[11,"new","","Create a new `Topo`, using the graph&#39;s visitor map, and put all\ninitial nodes in the to-visit list.",40,{"inputs":[{"name":"g"}],"output":{"name":"self"}}],[11,"reset","","Clear visited state, and put all initial nodes into the visit list.",40,{"inputs":[{"name":"topo"},{"name":"g"}],"output":null}],[11,"next","","Return the next node in the current topological order traversal, or\n`None` if the traversal is at the end.",40,{"inputs":[{"name":"topo"},{"name":"g"}],"output":{"name":"option"}}],[11,"clone","","",41,{"inputs":[{"name":"subtopo"}],"output":{"name":"subtopo"}}],[11,"from_node","","Create a new `SubTopo`, using the graph&#39;s visitor map, and put single\nnode in the to-visit list.",41,{"inputs":[{"name":"g"},{"name":"n"}],"output":{"name":"self"}}],[11,"reset_with_node","","Clear visited state, and put a single node into the visit list.",41,{"inputs":[{"name":"subtopo"},{"name":"g"},{"name":"n"}],"output":null}],[11,"next","","Return the next node in the current topological order traversal, or\n`None` if the traversal is at the end.",41,{"inputs":[{"name":"subtopo"},{"name":"g"}],"output":{"name":"option"}}],[0,"unionfind","petgraph","`UnionFind&lt;K&gt;` is a disjoint-set data structure.",null,null],[3,"UnionFind","petgraph::unionfind","`UnionFind&lt;K&gt;` is a disjoint-set data structure. It tracks set membership of *n* elements\nindexed from *0* to *n - 1*. The scalar type is `K` which must be an unsigned integer type.",null,null],[11,"clone","","",42,{"inputs":[{"name":"unionfind"}],"output":{"name":"unionfind"}}],[11,"fmt","","",42,{"inputs":[{"name":"unionfind"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Create a new `UnionFind` of `n` disjoint sets.",42,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"find","","Return the representative for `x`.",42,{"inputs":[{"name":"unionfind"},{"name":"k"}],"output":{"name":"k"}}],[11,"find_mut","","Return the representative for `x`.",42,{"inputs":[{"name":"unionfind"},{"name":"k"}],"output":{"name":"k"}}],[11,"union","","Unify the two sets containing `x` and `y`.",42,{"inputs":[{"name":"unionfind"},{"name":"k"},{"name":"k"}],"output":{"name":"bool"}}],[11,"into_labeling","","Return a vector mapping each element to its representative.",42,{"inputs":[{"name":"unionfind"}],"output":{"name":"vec"}}],[11,"adjacency_matrix","petgraph::graph","",12,{"inputs":[{"name":"graph"}],"output":{"name":"fixedbitset"}}],[11,"is_adjacent","","",12,{"inputs":[{"name":"graph"},{"name":"fixedbitset"},{"name":"nodeindex"},{"name":"nodeindex"}],"output":{"name":"bool"}}],[8,"EdgeType","petgraph","A graph&#39;s edge type determines whether is has directed edges or not.",null,null],[10,"is_directed","","",43,{"inputs":[],"output":{"name":"bool"}}],[8,"IntoWeightedEdge","","Convert an element like `(i, j)` or `(i, j, w)` into\na triple of source, target, edge weight.",null,null],[16,"NodeId","","",44,null],[10,"into_weighted_edge","","",44,null],[11,"hash","","",0,null],[11,"cmp","","",0,{"inputs":[{"name":"edgedirection"},{"name":"edgedirection"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"edgedirection"},{"name":"edgedirection"}],"output":{"name":"option"}}],[11,"eq","","",0,{"inputs":[{"name":"edgedirection"},{"name":"edgedirection"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"edgedirection"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"edgedirection"}],"output":{"name":"edgedirection"}}],[11,"opposite","","Return the opposite `EdgeDirection`.",0,{"inputs":[{"name":"edgedirection"}],"output":{"name":"edgedirection"}}],[11,"fmt","","",45,{"inputs":[{"name":"directed"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",45,{"inputs":[{"name":"directed"}],"output":{"name":"directed"}}],[11,"fmt","","",46,{"inputs":[{"name":"undirected"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",46,{"inputs":[{"name":"undirected"}],"output":{"name":"undirected"}}],[11,"is_directed","","",45,{"inputs":[],"output":{"name":"bool"}}],[11,"is_directed","","",46,{"inputs":[],"output":{"name":"bool"}}]],"paths":[[4,"EdgeDirection"],[3,"Ptr"],[3,"GraphMap"],[3,"Nodes"],[3,"Neighbors"],[3,"Edges"],[3,"AllEdges"],[3,"Node"],[3,"Edge"],[8,"IndexType"],[3,"NodeIndex"],[3,"EdgeIndex"],[3,"Graph"],[3,"Externals"],[3,"Neighbors"],[3,"Edges"],[3,"NodeWeightsMut"],[3,"EdgeWeightsMut"],[3,"WalkNeighbors"],[3,"WalkEdges"],[3,"NodeIndices"],[3,"EdgeIndices"],[4,"Config"],[3,"Dot"],[3,"AsUndirected"],[3,"Reversed"],[3,"Dfs"],[3,"Bfs"],[8,"Graphlike"],[8,"NeighborIter"],[8,"NeighborsDirected"],[8,"Externals"],[8,"VisitMap"],[8,"Visitable"],[8,"Revisitable"],[8,"GetAdjacencyMatrix"],[3,"FixedBitSet"],[3,"HashSet"],[3,"DfsIter"],[3,"BfsIter"],[3,"Topo"],[3,"SubTopo"],[3,"UnionFind"],[8,"EdgeType"],[8,"IntoWeightedEdge"],[4,"Directed"],[4,"Undirected"]]};
searchIndex["fixedbitset"] = {"doc":"**FixedBitSet** is a simple fixed size set of bits.","items":[[3,"FixedBitSet","fixedbitset","**FixedBitSet** is a simple fixed size set of bits that can\nbe enabled (1 / **true**) or disabled (0 / **false**).",null,null],[11,"hash","","",0,null],[11,"cmp","","",0,{"inputs":[{"name":"fixedbitset"},{"name":"fixedbitset"}],"output":{"name":"ordering"}}],[11,"partial_cmp","","",0,{"inputs":[{"name":"fixedbitset"},{"name":"fixedbitset"}],"output":{"name":"option"}}],[11,"lt","","",0,{"inputs":[{"name":"fixedbitset"},{"name":"fixedbitset"}],"output":{"name":"bool"}}],[11,"le","","",0,{"inputs":[{"name":"fixedbitset"},{"name":"fixedbitset"}],"output":{"name":"bool"}}],[11,"gt","","",0,{"inputs":[{"name":"fixedbitset"},{"name":"fixedbitset"}],"output":{"name":"bool"}}],[11,"ge","","",0,{"inputs":[{"name":"fixedbitset"},{"name":"fixedbitset"}],"output":{"name":"bool"}}],[11,"eq","","",0,{"inputs":[{"name":"fixedbitset"},{"name":"fixedbitset"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"fixedbitset"},{"name":"fixedbitset"}],"output":{"name":"bool"}}],[11,"fmt","","",0,{"inputs":[{"name":"fixedbitset"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"with_capacity","","Create a new **FixedBitSet** with a specific number of bits,\nall initially clear.",0,{"inputs":[{"name":"usize"}],"output":{"name":"self"}}],[11,"grow","","Grow capacity to **bits**, all new bits initialized to zero",0,{"inputs":[{"name":"fixedbitset"},{"name":"usize"}],"output":null}],[11,"len","","Return the length of the **FixedBitSet** in bits.",0,{"inputs":[{"name":"fixedbitset"}],"output":{"name":"usize"}}],[11,"contains","","Return **true** if the bit is enabled in the **FixedBitSet**,\n**false** otherwise.",0,{"inputs":[{"name":"fixedbitset"},{"name":"usize"}],"output":{"name":"bool"}}],[11,"clear","","Clear all bits.",0,{"inputs":[{"name":"fixedbitset"}],"output":null}],[11,"insert","","**Panics** if **bit** is out of bounds.",0,{"inputs":[{"name":"fixedbitset"},{"name":"usize"}],"output":null}],[11,"set","","**Panics** if **bit** is out of bounds.",0,{"inputs":[{"name":"fixedbitset"},{"name":"usize"},{"name":"bool"}],"output":null}],[11,"as_slice","","View the bitset as a slice of `u32` blocks",0,null],[11,"as_mut_slice","","View the bitset as a mutable slice of `u32` blocks. Writing past the bitlength in the last\nwill cause `contains` to return potentially incorrect results for bits past the bitlength.",0,null],[11,"clone","","",0,{"inputs":[{"name":"fixedbitset"}],"output":{"name":"self"}}],[11,"index","","",0,{"inputs":[{"name":"fixedbitset"},{"name":"usize"}],"output":{"name":"bool"}}]],"paths":[[3,"FixedBitSet"]]};
initSearch(searchIndex);
